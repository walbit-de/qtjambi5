Note: moved to our website, http://qt-jambi.org/material/qt-in-java

- Rationale
  * why'd we do it
  * What we offer
    - Qt in Java (the api)
    - Generator
    - Native look and feel
    - Signal and slot mechanism
    - fast
    - separate between convicing Qt/C++ crowd vs Swing crowd.

- Binding Technology
  * Autogenerated
  * JNI basedx
  * shell classes
  * Generator
  * Code samples
  * Coping with language conceptual differences
    - Multiple inheritance
    - Templates
    - pointers (*) and references (&)

- How cool we are
  * Graphics and examples.

- Final words
  * C#, we did it already, we can do it again.
  * Java versions supported
  * Enterprice vs standard

---
Things we don't mention:

[subsection] Not possible to create traditional Qt plugins from java.
// TODO

---

[section]
Qt in Java

Qt in Java is implemented as a thin layer around the Qt/C++
library. Each method call made to a Qt/Java class is redirected to
the C++ class.


[subsection] Signals and Slots

Signals and slots are used for communication between components. The
signals and slots mechanism is a central feature of Qt and probably
the part that differs most from the features provided by other
frameworks.

The traditional approach for inter-component communcation in Java is
using the listener pattern. This has the disadvantage that when
components are written they needs to know about all the interfaces
they intend to support. Consider a image viewer and a slider for
zooming. If the two components are written independently one would
need a separate class connecting them.

A signal is emitted when a particular event occurs. Qt's widgets have
many predefined signals, but we can always subclass widgets to add our
own signals to them. A slot is a method that is called in reponse to
a particular signal. In Qt/Java, all methods are treated as
slots. If we then revisit the slider and image viewer example it is
possible to connect the slider's "value" signal to the image viewers
setZoom method.

Signals in Java are declared as this:

public class Slider {
    protected Signal1<Integer> value = new Signal1<Integer>();
    ...
};

Connecting a signal to a method is done like this:

    connect(slider.value, imageViewer, "setZoom(int)");

As one can see from the example, Qt/Java makes use of Java Generics to
make the inter-component communication type safe. The number "1"
specifies that its a signal that emits one argument.

Qt/Java also supports the convenient connectSlotsByName() mechanism
which makes it possible to automatically connect to a childs signal by
following a naming conventions. For instance to react to the signal
"clicked" in a childwidget called "okButton", the following syntax can
be used:

public void on_okButton_clicked() { ... }


[subsection] Threading

Both Qt/C++ and Java provides its own threading API, where the Java
approach is integrated into the programming language, with features
such as synchronization using the \c {synchronized} keyword and
execution encapsulation using the \c {java.lang.Runnable}
interface. With these possibilities built into the language, we
decided to take advantage of those and layer threading Qt/Java on top
of the existing Java threading API, so that QObject::thread() in Java
returns a \c{java.lang.Thread}.

Existing threading concepts from Qt/C++ are present in Qt/Java, such
as posting events to objects in another thread and queued signal/slot
connections across different threads.


[subsection] Application Resource Management

Qt 4 has a system for embedding resources, binary and textual, into an
application and for accessing these at runtime, making it possible to
install a single binary with out external dependencies on icons,
translation files, etc.

In Java it is common to bundle all these resources into a .jar file
and ship the application as a .jar file instead. Accessing arbitrary
resources in such a jar file can be a tedious task, so Qt/Java
provides a file engine for traversing the classpath. This makes it
easy to embed and access resourses in .jar. The following example will
load the pixmap \c{file_new.png} from the filesystem or from a .jar
file in the classpath in the subdirectory \c {images}.

QPixmap pixmap = new QPixmap(":cp:images/file_new.png");


[subsection] Objects ownership and garbage collection

When native API's are mapped through the JNI it is common that
resources need to

It is a well known fact that much of the work being invested into
traditional C++ development is related to memory management. Java
provides garbage collection. When these two languages are merged,
through the Java Native Interface, it is common that native resources
need to be released manually from Java. The primary pattern for this
is to implement a dispose() method that releases handles the
cleanup. By reimplementing the finalize() method, which is called when
the object is garbage collected, it is sometimes possible to automate
cleanup of native resources.

Qt/C++ provides several mechanisms to simplify memory
management. These techniques include smart pointers, value types and
object trees, where the latter two are the most relevant for Qt/Java.
Value types are "simple" types, like QRect, QPoint which are passed
around between different objects. In Qt/Java these objects are garbage
collected as any normal Java objects. Subclasses of QObject will
normally follow a different set of rules since they have a lifetime
beyond what is visible to the Java garbage collector, such as toplevel
widgets. The rules that apply to widgets are that top level widgets
need to be explicitly disposed to be cleaned up and child widgets are
disposed automatically by their parent, so by diposing the toplevel
window one will cover all cases.


[subsection] Event system

Qt/Java implements its own event system based on Qt/C++. This event
loop is separate from the one in other toolkits such as AWT/Swing or
in SWT. As a concequence, it is not possible to have Qt/Java widgets
and widgets from other toolkits in the same part of the user
interface. Having a toplevel window running Qt/Java and another
toplevel window running AWT/Swing does not run into this limitation.

Although it is possible to merge event loops for different toolkits,
so that a QPushButton can inhabit a JSplitPane, it often not desired
as this means that different parts of the same user inteface may have
slightly different look&feel. Different repaint behaviour, fonts etc.


[subsection] Separate render pipeline

Qt/Java implements its own render pipeline based on the Qt Painting
Subsystem and requires that graphics related tasks, such as painting,
text handling, printing and imaging goes through the Qt/Java Classes.

Some of the advantages of this is that graphics processing is done
primarly in C++, making it faster than normal graphics in Java.

Qt's text handling is also based on native font support so it is
possible to get access to platform features like ClearType(tm)
anti-aliasing on Windows and Mac OS X, and sub-pixel anti-antiasing on
X11. Features that are currently not supported by the Java 2D graphics
subsystem.


[subsection] Enums and QFlags

Enums in Java and enums in C++ aim to provide the same functionallity,
namely typesafe constant values, but are implemented using fairly
different techniques. Enums in C++ are integers. Enums in Java are
objects and enums with defaultvalues are implemented as a special enum
subclass with limited use, for instance comparrason between types is
not possibe (read: its all a nasty hack).

Since enums in Qt are used as both enums and bitmasks the Java enum
class construction is too limited to be used. Enums and QFlags in
Qt/C++ are mapped to integers in Qt/Java.


[subsection] Polymorphism

The Qt C++ class hierarchy is object oriented and relies on
polymorphism, a concept that needs to be preserved when the Qt classes
are mapped in Java. Qt/Java has built in functionallity to forward any
virtual function call made in C++ to Java so that when for instance
QWidget:mouseMoveEvent() is called, the Java implementation will be
called instead. Making these calls into Java for each method call is
a vaste of cpu so Qt/Java optimizes away all redundant calls, so that
only methods reimplemented in user classes are called.


[subsection] Type Mapping

There are some classes in Java that are more suitable for programming
in Java than their Qt counter parts. The String class for instance
which is integrated into the language and has builtin in support for
the + operator, and the Java collection classes are supported in using
the foreach keyword. For these cases the Qt/Java API will implictly
convert between the Qt/C++ types to the Java types so that programmers
can write code using the familiar and convenient constructs of Java
while still accessing the power of Qt.

The following classes are mapped from Qt to Java:
Qt      | Java
----------------+---------------
QString     | java.lang.String
QChar       | char and java.lang.Character
QMap        | java.util.Map
QList       | java.util.List


[subsection] Member Variable Access

The Qt/C++ API is primarly method based, but there are some classes
that give direct access to the member variables of an object. Since
JNI only provides access to native resources through functions, each
of these member variables is prepresented as set/get method pair with
the following name convention.

C++:
QString text;

Java:
String get_text();
void set_text(String text);


[subsection] Pointer based API's

The C++ concept of pointers, references and multiple layers of
indirection does not map directly into similar concepts in Java, but
Qt/Java is based on API that relies on these concepts. Qt/Java tries
to match normal types into wrapper classes in Java where possible. For
instance:

C++               Java
------------------------
QWidget *      | QWidget
QString        | String
etc.

Other concepts, such as:

void process(int *data);

does not map automatically. In the above example, the variable data
can have three different purposes. It could be an "in" value, an
"out", value or an array of integers. In cases such as this we have
introduced the concept of a native pointer (QNativePointer) which
encapsulates the pointer and lets the programmer access it as an
in/out value and as an array. The QNativePointer API also provides
type checks to verify that one does not incorrectly access a byte as
int or char ** as a void *, etc.

In most cases where native pointers are used in Qt, the Qt/Java layer
will encapsulate their use with more convenient and bulletproof API's.

[subsection] code samples
// TODO


[subsection] UIC for Java

Qt/Java comes with its own generator for UIC. UIC is a tool for
generating code from UI forms created with Qt Designer, a powerful
user interface builder that is tailored for the Qt API.

UIC for Java generates Qt/Java code and provides features that makes
it easy to integrate into a build environment or for stand alone use
in a command shell.

[subsection] QVariant

Qt/C++ does, as mentioned above, have the concept of value types. In
addition to the concrete value types, Qt also comes with abstract
value type. A value that can represent any value and possible be
converted to any other value. In Qt/C++ this concept works very well
because of built in features of C++ like, implicit conversions. In
Java these conversions must be done explicitly and the code would not
look nice. To preserve the convenient syntax of C++, Qt/Java uses the
java.lang.Object type as container for variants. For mapping between
types we provide a series of static functions
org.qtjambi.qt.QVariant. This provide the convenient usage pattern
from C++ in addition to providing the same set of features.

[subsection] Resource system

Qt/C++ offers the possibility of embedding resources, such as language
files and icons, into the compiled binary.
